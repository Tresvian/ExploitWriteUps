# Stack buffer overflow

This first one is very basic demonstration of memory corruption.

In the source code, a struct is created with a char[64] array and a volatile int after it. While debugging, I'm able to see subrsp, 0x60 allocating local vars for main. The debugger shows that our volatile int is at rbp-0x10, while our char array is rbp-0x50.

If we were to fill more data than 64chars, then the stack pointer will proceed on to copy contents until it hits rbp-0x11, before hitting rbp-x010. However, gets() doesn't know the amount of data to get, so it will keep going until it fits the area.
